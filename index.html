<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Layered Coloring Canvas</title>
  <style>
    body {
      background: #111;
      color: white;
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }
    #palette button {
      width: 32px;
      height: 32px;
      margin: 0 5px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.1s ease;
    }
    #palette button:hover { transform: scale(1.2); }
    #selectedColor {
      width: 32px;
      height: 32px;
      display: inline-block;
      border: 2px solid white;
      border-radius: 4px;
      vertical-align: middle;
      margin-left: 10px;
    }
    #hexInput {
      width: 100px;
      padding: 4px 8px;
      font-size: 16px;
      margin-left: 15px;
      border-radius: 4px;
      border: none;
    }
    #container {
      position: relative;
      margin: auto;
      user-select: none;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      display: block;
    }
    #infoBox {
      margin-top: 10px;
      font-family: monospace;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h1>Layered Coloring Canvas</h1>
  <div id="palette"></div>
  <div style="display: inline-block;">
    Selected: <div id="selectedColor"></div>
    <input id="hexInput" type="text" placeholder="#RRGGBB" maxlength="7" />
  </div>
  <div id="container"></div>
  <div id="infoBox">
    Coordinates: <span id="coords">??, ??</span> |
    Canvas Size: <span id="canvasSize">?? x ??</span>
  </div>

  <script>
    const defaultImageURL = "https://files.catbox.moe/kktsc1.json";
    const defaultBoundariesURL = "https://files.catbox.moe/fak5gd.json";

    const paletteColors = ["#ffffff", "#ff0000", "#00ff00", "#0000ff", "#ffff00", "#ff00ff", "#00ffff"];
    const paletteDiv = document.getElementById("palette");
    const selectedColorBox = document.getElementById("selectedColor");
    const hexInput = document.getElementById("hexInput");
    const coordsSpan = document.getElementById("coords");
    const canvasSizeSpan = document.getElementById("canvasSize");
    const container = document.getElementById("container");

    let selectedColor = "#ffffff";
    selectedColorBox.style.background = selectedColor;
    hexInput.value = selectedColor;

    paletteColors.forEach(color => {
      const btn = document.createElement("button");
      btn.style.background = color;
      btn.onclick = () => {
        selectedColor = color;
        selectedColorBox.style.background = color;
        hexInput.value = color;
      };
      paletteDiv.appendChild(btn);
    });

    hexInput.addEventListener("input", () => {
      const val = hexInput.value.trim();
      if (/^#[0-9A-Fa-f]{6}$/.test(val)) {
        selectedColor = val;
        selectedColorBox.style.background = val;
      }
    });

    let boundariesData, shapeColors = {}, origWidth, origHeight;
    let baseCanvases = [], coloringCanvas, coloringCtx;

    function pointInPolygon(x, y, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i][0], yi = polygon[i][1];
        const xj = polygon[j][0], yj = polygon[j][1];
        const intersect = ((yi > y) !== (yj > y)) &&
          (x < (xj - xi) * (y - yi) / ((yj - yi) || 1) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function getClickedShapeIndex(x, y) {
      for (let i = 0; i < boundariesData.boundaries.length; i++) {
        const shape = boundariesData.boundaries[i];
        if (pointInPolygon(x, y, shape.outer)) {
          if (shape.inner?.some(hole => pointInPolygon(x, y, hole))) continue;
          return i;
        }
      }
      return null;
    }

    function fillShape(ctx, shape, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(shape.outer[0][0], shape.outer[0][1]);
      shape.outer.forEach(([x, y]) => ctx.lineTo(x, y));
      ctx.closePath();
      shape.inner?.forEach(hole => {
        ctx.moveTo(hole[0][0], hole[0][1]);
        hole.forEach(([x, y]) => ctx.lineTo(x, y));
        ctx.closePath();
      });
      ctx.fill("evenodd");
    }

    function redrawColors(ctx) {
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      for (const index in shapeColors) {
        fillShape(ctx, boundariesData.boundaries[index], shapeColors[index]);
      }
    }

    function resizeCanvases() {
      const aspect = origWidth / origHeight;
      const maxW = window.innerWidth * 0.9;
      const maxH = window.innerHeight * 0.7;

      const scale = Math.min(maxW / origWidth, maxH / origHeight);
      const width = origWidth * scale;
      const height = origHeight * scale;

      [ ...baseCanvases, coloringCanvas ].forEach(c => {
        c.style.width = width + "px";
        c.style.height = height + "px";
      });

      container.style.width = width + "px";
      container.style.height = height + "px";
      canvasSizeSpan.textContent = `${origWidth} x ${origHeight}`;
    }

    async function start() {
      const [imagesRes, boundsRes] = await Promise.all([
        fetch(defaultImageURL),
        fetch(defaultBoundariesURL)
      ]);
      const imageData = await imagesRes.json();
      boundariesData = await boundsRes.json();

      origWidth = boundariesData.width;
      origHeight = boundariesData.height;

      // Base layers
      baseCanvases = imageData.map(() => {
        const c = document.createElement("canvas");
        c.width = origWidth;
        c.height = origHeight;
        container.appendChild(c);
        return c;
      });

      imageData.forEach((src, i) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => baseCanvases[i].getContext("2d").drawImage(img, 0, 0);
        img.src = src;
      });

      coloringCanvas = document.createElement("canvas");
      coloringCanvas.width = origWidth;
      coloringCanvas.height = origHeight;
      container.appendChild(coloringCanvas);
      coloringCtx = coloringCanvas.getContext("2d");

      resizeCanvases();
      window.addEventListener("resize", resizeCanvases);

      coloringCanvas.addEventListener("mousemove", e => {
        const rect = coloringCanvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) * (origWidth / rect.width));
        const y = Math.floor((e.clientY - rect.top) * (origHeight / rect.height));
        coordsSpan.textContent = (x >= 0 && y >= 0) ? `${x}, ${y}` : "??, ??";
      });

      coloringCanvas.addEventListener("click", e => {
        const rect = coloringCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (origWidth / rect.width);
        const y = (e.clientY - rect.top) * (origHeight / rect.height);
        const shapeIndex = getClickedShapeIndex(x, y);
        if (shapeIndex !== null) {
          shapeColors[shapeIndex] = selectedColor;
          redrawColors(coloringCtx);
        }
      });
    }

    start();
  </script>
</body>
</html>
